# inputs

# define cache inputs - mqtt topics, how to parse them and put them into cache.
# see outputs.yaml for cache output as shdr.

# adapter subscribes to mqtt topics from devices.
# mqtt broker sends data to adapter.
# adapter parses messages, writes values to cache, which outputs shdr.

# this file is parsed by the adapter driver pipeline/adapter/src/drivers/mqtt-json.js.

# define connect handler
connect:
  # subscribe to these topics
  # can use ${deviceId} in topics
  subscribe:
    - topic: l99/ccs/evt/query
    - topic: l99/ccs/evt/status
    - topic: l99/ccs/evt/read
  # publish an empty message to receive the query response
  publish:
    - topic: l99/ccs/cmd/query
      message: '{}'
  # define any static one-time cache values to set
  static:
    # this sets the cache value at eg 'kl1-procname' to 'KITTING'
    procname: KITTING

# define message topic handlers
handlers:
  # ----------------------------------------------------------------------------
  # handle status messages
  # ----------------------------------------------------------------------------
  l99/ccs/evt/status:
    # make '$' the message payload dictionary and add faultKeys for quick
    # lookups of faults - payload.faults is a dictionary of faults.
    #. initialize: status_initializer
    initialize: '$ = payload; $.faultKeys=Object.keys(payload.faults);'
    # define lookup function, which returns a value given a part calculation.
    lookup: '($, part) => eval(part)'
    process: iterate_inputs
    # define key-part pairs, where key is mapped to a cache id,
    # eg 'status-connection' => 'pa1-status_connection',
    # and part is some javascript calculation code to determine its value.
    inputs:
      status_connection: $.connection
      status_build_no: $.build_no
      status_program: $.program
      status_step: $.step
      status_state: $.state
      status_utc_time: $.utc_time
      status_cpu_time: $.cpu_time
      status_faults: $.faults
      status_has_no_faults: $.faultKeys.length === 0
      status_has_faults: $.faultKeys.length > 0
      status_has_soft_faults: $.faultKeys.some(f => f>='50')
      status_has_hard_faults: $.faultKeys.some(f => f<'50')

  # ----------------------------------------------------------------------------
  # handle query messages
  # ----------------------------------------------------------------------------
  l99/ccs/evt/query:
    unsubscribe:
      - topic: l99/ccs/evt/query

    # $ is a way to do quick lookups on the mqtt payload.
    # the payload is an array of items like [{ address, keys, default, value }, ...].
    # $ is a variable declared as `let $ = {}` before this code is executed.
    #. hide this code from user in plugin code - eg have keywords for fn to use -
    # initialize: query_initializer
    initialize: 'payload.forEach(item => $[item.address] = item)'

    # # define a lookup function to use to get item from payload, if there.
    # lookup: '($, part) => ($[part] || {}).default'
    # accessor to use to get value from message item
    accessor: default

    # # this code would get evaluated in the scope of the calculations
    # #. move initialize here etc
    # definitions:
    #   - let msg = ($, part) => ($[part] || {}).default
    #   - let keyvalues = {}

    # algorithm to process inputs
    process: iterate_message_contents

    # define key-code pairs
    # 'key' defines the cache id, with id = {deviceId}-{key},
    # eg for key='printer_ribbon_low', id = 'pa1-printer_ribbon_low'.
    # 'code' defines the part of the payload to get using the above defined
    # lookup fn, eg for code: =msg('%I0.0'), the value is obtained with msg('%I0.0').
    # then calls cache.set(id, value), eg cache.set('pa1-printer_ribbon_low', 0).
    # this might trigger SHDR output to be sent to the mtconnect agent,
    # according to the outputs defined in outputs.yaml.
    # the & syntax saves this list for later, as the read message handler
    # uses the same pairs.
    #. rename to codes?
    inputs: &queryInputs
      # --------------------------------------------------------
      # process occurrence
      # --------------------------------------------------------

      # flag for current job meta is not empty string
      # used in outputs.yaml for funcmode
      # this looks up %Z61.0 in the $ dictionary, which indexes the message addresses
      # this value is true or false, so both will be written to the cache.
      has_current_job: "=!!$['%Z61.0']" # converts object to true, undefined to false

      # get job meta data from kit label
      # this writes a value to the cache at eg key 'kl1-job_meta'.
      # this makes <job_meta> be the json object from the message.
      # if this mqtt message includes address %Z61.0,
      # this will assign its value to job_meta,
      # otherwise value will be undefined, and cache.set will ignore it,
      # leaving any existing value there in the cache.
      # this syntax would work, BUT we have other places where we need message refs,
      # so make it more explicit - see below
      # job_meta: '%Z61.0'
      # we need to pull out .default OR .value, depending on which handler this is
      # hence the msg lookup function def above.
      job_meta: =msg('%Z61.0')

      #. how specify printer assoc with this line?
      # need to specify pr1, pr2, pr3, pr4 etc
      # setup.yaml could specify? or part of the xml model?
      # piece_count_at_print_apply: |
      #   =(<job_meta> || {}).carton_quantity - cache.get('pr1-labels_remaining')

      # get value for pctarg/pctarget
      # <foo> is a cache lookup, eg cache.get('kl1-foo')
      # if job_meta is undefined, this expression is undefined, and the cache won't be updated.
      carton_quantity: =(<job_meta> || {}).carton_quantity

      # check if eye1 or eye2 counts changed, set flags
      # msg('Z61.5') gives you the part count in the CURRENT message, if any
      # <kits_on> gives you the current value in the cache
      #. do we need these though? change detection will be automatic
      # kits_on_changed: =msg('Z61.5') !== undefined && (<kits_on> !== msg('Z61.5'))
      # kits_off_changed: =msg('Z61.6') !== undefined && (<kits_off> !== msg('Z61.6'))

      # count of kits that have crossed eye1 on conveyer
      # note: if this address is NOT in the current message, the value is undefined,
      # so the cache value is NOT updated.
      kits_on: =msg('%Z61.5')

      # count of kits that have crossed eye2 on conveyer
      kits_off: =msg('%Z61.6')

      # used in outputs yaml
      first_eye_broken: =(<kits_on> > 0)

      # calculate cycle time for kit to go from eye1 to eye2

      # don't care about the cache key here, just want to assign something to keyvalue store
      # start_cycle_timer: |
      #   =if (<kits_on_changed>) { <keyvalues>[<kits_on>] = { start: new Date(), end: null, delta: null} }
      start_cycle_timer: =keyvalues[<kits_on>] = { start:new Date(), end:null, delta:null}

      # get cycle time when kits_off count changes
      # note: the if stmt evaluates to its last expression
      # cycle_time: |
      #   =if (<kits_off_changed>) {
      #     let koff = <keyvalues>[<kits_off>] || {};
      #     koff.end = new Date();
      #     koff.delta = koff.end - koff.start;
      #   }
      # note: block evaluates to its last expression
      cycle_time: |
        ={
          const koff = keyvalues[<kits_off>] || {};
          console.log('koff', koff)
          koff.end = new Date();
          koff.delta = koff.end - koff.start;
          return koff.delta;
        }

      # calculate average cycle time for current job.
      # the reference to <kits_off> forces a recalc when that changes.
      # note: dividing by objs.length gives NaN if it's zero, which is what we want
      cycle_time_avg: |
        ={
          const ref = <kits_off>;
          const objs = Object.values(keyvalues);
          const avg = objs
            .filter(obj=>obj.delta>0)
            .reduce((a,b)=>a+b.delta,0) / objs.length;
          return avg;
        }

      # get lastest cycle times to show in dataset
      cycle_times: |
        ={
          const kv = Object.entries(keyvalues);
          const dataitems = kv
            .slice(kv.length - 5)
            .map(([key, value]) => `${key}=${value.delta}`)
            .join(' ');
          return dataitems;
        }

      pieces_in_assembly: =<kits_on> - <kits_off> # kits on assy line
      pieces_completed: =<kits_off> # kits finished
      pieces_began: =<kits_on> # kits work began

      # current job done, pieces remaining reached zero
      #. need explicit true here, so undefined -> false (undefined would leave this as true)
      job_complete: =msg('%Z61.3') === true

      #. these no longer get executed in order, so failing - what do?

      # compare cache to incoming data
      job_changed: =<has_current_job> && (<job_current> !== <job_meta>.kit_number)

      # kit assembly part number, can be empty string
      job_current: =<has_current_job> && <job_meta>.kit_number

      # assign new uuid's and time on job change
      part_uuid: '=<job_changed> ? uuid() : undefined'
      process_uuid: '=<job_changed> ? uuid() : undefined'
      job_start: '=<job_changed> ? new Date().toISOString() : undefined'

      salesord: '=<job_changed> ? <job_meta>.sales_order_number : undefined'

      # #. data coming from skid label, ChrisE needs to define address
      #. is this the salesqueue.dictionary? so multiple purchase orders?
      # purchord: =($['%Z61.x'] || {}).purchase_order_number
      # purchord: =(msg('%Z61.13') || {}).purchase_order

      reset_key_values: ={ if (<job_changed>) { keyvalues = {} } }

      # --------------------------------------------------------
      # part occurrences
      # --------------------------------------------------------

      date_code: =(<job_meta> || {}).assembled_date

  # ----------------------------------------------------------------------------
  # handle read messages
  # ----------------------------------------------------------------------------
  l99/ccs/evt/read:
    # make $ a dictionary keyed on the item addresses
    initialize: 'payload.forEach(item => $[item.address] = item)'
    # accessor to use to get value from message item
    accessor: value
    # how to process inputs
    process: iterate_message_contents
    # reuse the query input list here with *, as the key-part pairs are the same
    inputs: *queryInputs

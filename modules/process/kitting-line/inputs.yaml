# inputs
# define cache inputs - mqtt topics, how to parse them and put them into cache.
# see outputs.yaml for cache output as shdr.

# adapter subscribes to mqtt topics from devices.
# mqtt broker sends data to adapter.
# adapter parses messages, writes values to cache, which outputs shdr.

# this file is parsed by the adapter driver pipeline/adapter/src/drivers/mqtt-json.js.

# define connect handler
connect:
  # subscribe to these topics
  # can use ${deviceId} in topics
  subscribe:
    - topic: l99/${deviceId}/evt/query
    - topic: l99/${deviceId}/evt/status
    - topic: l99/${deviceId}/evt/read
  # publish an empty message to receive the query response
  publish:
    - topic: l99/${deviceId}/cmd/query
      message: '{}'

# define message topic handlers
handlers:
  # ----------------------------------------------------------------------------
  # handle status messages
  # ----------------------------------------------------------------------------
  l99/${deviceId}/evt/status:
    # make '$' the message payload dictionary and add faultKeys for quick
    # lookups of faults - payload.faults is a dictionary of faults.
    # initialize: '$ = payload; $.faultKeys=Object.keys(payload.faults);'
    initialize: '$ = payload'
    # define lookup function, which returns a value given a part calculation.
    lookup: '($, part) => ({ value: eval(part) })'
    # define key-part pairs, where key is mapped to a cache id,
    # eg 'status-connection' => 'pa1/status-connection',
    # and part is some javascript calculation code to determine its value.
    inputs:
      status-connection: $.connection
      status-build_no: $.build_no
      status-program: $.program
      status-step: $.step
      status-utc_time: $.utc_time
      status-cpu_time: $.cpu_time
      status-faults: $.faults
      status-has-no-faults: $.faultKeys.length === 0
      status-has-faults: $.faultKeys.length > 0
      status-has-soft-faults: $.faultKeys.some(f => f>='50')
      status-has-hard-faults: $.faultKeys.some(f => f<'50')

  # ----------------------------------------------------------------------------
  # handle query messages
  # ----------------------------------------------------------------------------
  l99/${deviceId}/evt/query:
    unsubscribe:
      - topic: l99/${deviceId}/evt/query

    # $ is a way to do quick lookups on the mqtt payload.
    # in this case the payload is an array of items like { keys, default }.
    # what we want to do is assign the default value to each item's key,
    # where the key is keys[0], eg 'printer_ribbon_low'.
    # $ is a variable declared as `let $ = {}` before this code is executed.
    #. this complexity could be hidden from the user in the plugin code somehow.
    initialize: 'payload.forEach(item => $[item.keys[0]] = item)'
    lookup: '($, part) => ({ value: ($[part] || {}).default })'

    # define key-part pairs
    # 'key' defines the cache id, with id = {deviceId}/{key},
    # eg for key='printer_ribbon_low', id = 'pa1/printer_ribbon_low'.
    # 'part' defines the part of the payload to get using the above defined
    # lookup fn, eg for part='%I0.0', the value is obtained with $['%I0.0'].
    # then it sets item = { value }, then calls cache.set(id, item),
    # eg cache.set('pa1/printer_ribbon_low', { value: 0 })
    # this might trigger SHDR output to be sent to the mtconnect agent,
    # according to the outputs defined in outputs.yaml.
    # the & syntax saves this list for later, as the read message handler
    # uses the same pairs.
    inputs: &queryInputs
      kit-on: '%Z61.5' # kit placed on conveyer - eye1
      kit-off: '%Z61.6' # kit removed from conveyer - eye2

      # before and after fire only when new incoming 'job_current'
      job-changed#before: <job_current.last'> = <job_current>
      job-changed: <job_current.last> != 'job_current'            # comparing cache to incoming data
      job-changed#after: <job_changed> ? false : <job_changed>    # needs to reset after evaluation back to 'false', 
                                                                  # account for same incoming 'job_current' as previous 'job_current'

      part-uuid: if <job-changed> new uuid()
      process-uuid: if <job-changed> new uuid()

      salesord: '%Z61.0'.to_json().sales_order_number



  # ----------------------------------------------------------------------------
  # handle read messages
  # ----------------------------------------------------------------------------
  l99/${deviceId}/evt/read:
    # make $ a dictionary keyed on the item addresses
    initialize: 'payload.forEach(item => $[item.address] = item)'
    lookup: '($, part) => ({ value: ($[part] || {}).value })'
    # reuse the query input list here with *, as the key-part pairs are the same
    inputs: *queryInputs

# outputs

# these outputs are placed in the module.xml tree and define the
# shdr strings that are calculated from the cache and sent to the agent.

# the item's id in the xml and the shdr key is `${deviceId}/${key}`
# the shdr value is defined with the item value code.

# value is javascript, evaluated by the cache in calculating the shdr output.
# <foo> is a cache lookup, shorthand for cache.get('${deviceId}/foo').value

# category is used to determine shdr representation.
# default category is EVENT or SAMPLE - specify for others.
# specify type if is MESSAGE.
# see end of pipeline/adapter/src/cache.js for details.

outputs:
  # device

  - key: avail
    value: types.AVAILABILITY[<status-connection>]

  - key: func
    value: if has_current_job and piece_count == 0       'SETUP'
      else if has_current_job and piece_count > 0   'PRODUCTION'
      else if has_current_job and done == true      'TEARDOWN'
      else if not has_current_job                   'x:IDLE'

  # controller

  - key: exec
    value: types.EXECUTION[<status-state>]

  - key: wait
    value: types.WAIT_STATE[<status-state>]

  - key: emp
    value: "types.AVAILABILITY[<status-connection>]=='AVAILABLE' ? 'ON' : 'OFF'"

  - key: pgm
    value: <status-program>

  - key: step
    type: BLOCK
    value: <status-step>

  - key: clk_time
    type: CLOCK_TIME
    value: <status-utc_time>

  - key: up_time
    type: EQUIPMENT_TIMER
    subType: OPERATING
    value: <status-cpu_time>

  - key: fw
    type: FIRMWARE
    subType: VERSION
    value: <status-build_no>

  - key: msg
    type: MESSAGE
    # representation: DATA_SET # set of kv pairs, part2 7.2.2.12 line 1082
    # value: Object.entries(<status-faults>).map(([id, fault]) => id + '="' + fault.description + '"').join(' ')
    # value: "'msg|' + Object.entries(<status-faults>).map(([id, fault]) => 'f' + id + '=pokpok').join(' ')"
    # value: "Object.entries(<status-faults>).map(([id, fault]) => id + ': ' + fault.description).join(', ')"
    #. escape any pipes and enclose in double quotes
    value: "Object.entries(<status-faults>).map(([id, fault]) => fault.description).join(', ')"
    nativeCode: NativeCode #.

  - key: cond
    category: CONDITION
    value: "<status-has-hard-faults> ? 'FAULT' : <status-has-soft-faults> ? 'WARNING' : 'NORMAL'"

  # parts

  # process

  - key: poid
    type: PROCESS_OCCURENCE_ID
    value: <process-uuid>

  - key: salesord
    type: PROCESS_AGGREGATE_ID
    value: <salesord>

  # - key: procname
  #   value: KITTING # nowork - needs a cache key to detect a change ehh

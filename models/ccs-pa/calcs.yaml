# calcs

# these items are placed in the model.yaml tree and define the
# shdr strings that are calculated and sent to the agent.

# the item's key (eg 'connection') together with the deviceId (eg 'ccs-pa-001')
# will become its id in the xml (eg 'ccs-pa-001-connection').
# the shdr key is the same as the id.
# the shdr value is defined with the item value code.

# the value calculations are gathered together into a calcs.js file,
# which is imported to the adapter plugin.
# or this file is iterated over and items are added to the cache calcs.

# for values, <foo> is shorthand for cache.get('${deviceId}-foo').value

calcs:
  connection:
    category: EVENT
    type: AVAILABILITY
    value: types.AVAILABILITY[<status-connection>]

  # eg change tool to a drill etc - irrelevant to p&a
  asset_changed:
    category: EVENT
    type: ASSET_CHANGED # see std pt 4 line 347
    value:

  asset_removed:
    category: EVENT
    type: ASSET_REMOVED # see std pt 4 line 357
    value:

  dev_cond:
    category: CONDITION
    type: SYSTEM
    # any hard faults? = FAULT, any soft faults? = WARNING, no faults = NORMAL
    value: |
      const nums = Object.keys(<status-faults>)
      const hard = nums.some(num => num < 50)
      const soft = nums.some(num => num >= 50)
      const str = hard ? 'FAULT' : soft ? 'WARNING' : 'NORMAL'
      return str

  dev_msg:
    category: EVENT
    type: MESSAGE
    representation: DATA_SET # set of kv pairs, part2 7.2.2.12 line 1082
    # value: fault_id:fault_value, fault_id:fault_value, ...
    value: |
      const faults = Object.values(<status-faults>)
      const str = faults.map(fault => fault.id + ':' + fault.description).join(', ')
      return str

  fw_ver:
    category: EVENT
    type: FIRMWARE
    subType: VERSION
    value: <status-build_no>

  e_stop:
    category: EVENT
    type: EMERGENCY_STOP
    # value: "<status-faults>.any([10]) ? 'TRIGGERED' : 'ARMED'"
    value: |
      const nums = Object.keys(<status-faults>)
      const str = types.EMERGENCY_STOP[nums.some(num => num===10)]
      return str

  state:
    category: EVENT
    type: EXECUTION
    value: types.EXECUTION[<status-state>]

  wait_state:
    category: EVENT
    type: WAIT_STATE
    #. what value goes here when status.state is not WAIT?
    value: types.WAIT_STATE[<status-state>]

  program:
    category: EVENT
    type: PROGRAM
    subType: MAIN
    value: <status-program>

  step:
    category: EVENT
    type: BLOCK
    value: <status-step>

  clk_time:
    category: SAMPLE
    type: CLOCK_TIME
    value: <status-utc_time>

  up_time:
    category: SAMPLE
    type: EQUIPMENT_TIMER
    subType: OPERATING
    value: <status-cpu_time>

  fault_count:
    category: SAMPLE
    type: COUNT
    value: <%M55.2>

  cycle_count:
    category: SAMPLE
    type: COUNT
    value: <%M55.1>

  life_count:
    category: SAMPLE
    type: COUNT
    value: <%M55.0>

  printer_start_print:
    category: EVENT
    type: ACTUATOR_STATE
    value: types.ACTUATOR_STATE[<%Q0.0>]

  printer_feed:
    category: EVENT
    type: ACTUATOR_STATE
    value: types.ACTUATOR_STATE[<%Q0.1>]

  printer_pause:
    category: EVENT
    type: ACTUATOR_STATE
    value: types.ACTUATOR_STATE[<%Q0.2>]

  end_eff_cond:
    category: CONDITION
    type: SYSTEM
    # value needs quotes here because has ':' in expression
    # value: "(cache.get('${deviceId}-status-faults').any([2,3,5])) ? 'FAULT' : 'NORMAL'"
    # value: types.CONDITION[<status-faults>.any([2,3,5]))]

  end_eff_message:
    category: EVENT
    type: MESSAGE
    # value: cache.get('${deviceId}-status-faults').first([2,3,5]).property('description').value
    # value: <status-faults>.first([2,3,5]).property('description').value

  # #. should this go here or elsewhere?
  # operator:
  #   category: EVENT
  #   type: USER
  #   subType: OPERATOR
  #   value: <operator>
